=== セッション管理

ログイン機能を実装するには、サーバへの一連のリクエストを一つのトランザクションとして扱えるようにする必要があります。

HTTPリクエストはそれぞれ独立したトランザクションなので、これらを一つのトランザクションとして扱えるようにしなくてはHTTPリクエスト毎に認証を行う必要があるのです。

この複数のリクエストをまとめたトランザクションのことをセッションと呼びます。

Railsでは**session**メソッドを使って一時セッションを作成できます。
今回はこれを使ってログインを実装しましょう。

ログインしたら一時セッションを作成し、セッションにユーザIDを保存します。
そして、次回以降のリクエストではセッションに保存されたユーザIDをみてログイン状態を判断します。

[NOTE]
.一時Sessionと永続Cookies
====
一時セッションの場合、ブラウザ再起動などを行うとセッションが破棄されてしまいます。

ブラウザを閉じてもログイン状態を維持したい場合は、**cookies**メソッドを使って永続cookiesにユーザIDを保存します。

ただし、永続cookiesは有効期間が長いため、セッションハイジャックの危険性が高くなります。
これにたいして対策する必要があります。

例えば、ユーザIDだけではなく有効期間を持つトークンも永続cookiesへ保存し、ログイン状態を確認する際にこのトークンのチェックも行うようにすることで、一時セッションと同様にセッションの有効期間を短くするという方法が考えられます。


====

[NOTE]
.SessionとCookies
====
Railsのデフォルト設定ではsessoinメソッドによる一時セッションは、ブラウザのcookiesへセッションの内容を暗号化して保存する**CookieStore**という仕組みが使用されます。

そこそこ安全ではありますが、秘密鍵が漏れるとあっさりと内容を見られてしまうので、致命的な情報を扱うのには向いていません。

致命的な情報を扱うならブラウザのcookiesにはセッション識別子だけを保存し、セッションの内容はDBに保存する**ActiveRecordSessionStore**という仕組みを使うのが良いでしょう。

ActiveRecordSessionStoreは**activerecord-session_store**というgemを入れることで簡単に導入できます。


====


セッションを管理するためのコントローラを作成します。
ログイン画面表示のための**new**アクションも追加しておきましょう。

リクエストとしては他にもログイン（セッション作成）とログアウト（セッション破棄）がありますが、これらはViewが不要なので、generateコマンドでは生成しません。

[source, console]
.セッションコントローラ生成
----
$ rails generate controller Sessions new
Running via Spring preloader in process 19696
      create  app/controllers/sessions_controller.rb
       route  get 'sessions/new'
      invoke  erb
      create    app/views/sessions
      create    app/views/sessions/new.html.erb
      invoke  test_unit
      create    test/controllers/sessions_controller_test.rb
      invoke  helper
      create    app/helpers/sessions_helper.rb
      invoke    test_unit
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/sessions.coffee
      invoke    scss
      create      app/assets/stylesheets/sessions.scss
----

次にルーティング設定です。
今回追加するリクエストは次のようにします。

[options="header"]
.セッションコントローラのルーティング
|====
| リクエスト | URL | アクション | 説明
| GET | /login | new | ログイン画面表示
| POST | /login | create | セッション作成(ログイン)
| DELETE | /login | delete | セッション破棄(ログアウト)
|====

上記のルーティング設定を `routes.rb` に追加します。

[source, rb]
----
Rails.application.routes.draw do
  root 'static_pages#home'
  resources :users

  get '/login', to:'sessions#new'
  post '/login', to:'sessions#create'
  delete '/logout', to:'sessions#destroy'
end
----

==== ログイン画面

ログイン画面を作成します。

Viewを実装します。
メールアドレス（ユーザ名）とパスワードの入力項目を持つフォームとします。
編集内容がモデルと対応しないので、formがpostする先のパスを明示的に指定します。

ユーザ登録していない場合は、ユーザ登録を先に行う必要があるので、ユーザ登録画面へのリンクも設置します。

[source, erb]
.app/views/sessions/new.html.erb
----
<% provide(:title, "Log in") %>
<h1>Log in</h1>

<div class="row">
  <div class="col-md-6 col-md-offset-3">
    <%= form_for(:session, url: login_path) do |f| %> <!-- 1 -->

      <%= f.label :email %>
      <%= f.email_field :email, class: 'form-control' %>

      <%= f.label :password %>
      <%= f.password_field :password, class: 'form-control' %>

      <%= f.submit "Log in", class: "btn btn-primary" %>
    <% end %>

    <p>New user? <%= link_to "Sign up now!", new_user_path %></p>
  </div>
</div>
----

<1> フォーム作成。form_forのurlオプションでpost先のパスを指定している。フォームの入力内容は:sessionラベルに格納される。

フォームの編集内容はモデルに対応していないので、アクションで取得する場合は `params[:session][:email]` のようになります。

login_pathのPOSTリクエストのアクションはcreateです。
createアクションを実装しましょう。

フォームから受け取ったメールアドレスとパスワードを使って認証を行います。
認証に失敗した場合はログイン画面を再度表示します。

認証に成功した場合はログイン処理を行なった上でユーザ表示画面へリダイレクトします。
ログイン処理はまだ未実装なので、TODOとしておきます。

それから認証失敗をユーザに示すためにflushメッセージを設定しておきましょう。
今回は画面遷移ではなくrendarメソッドによる再表示になります。

画面遷移をしないため、前回と同様にflus変数にそのままメッセージを格納すると、この後他の画面に遷移後もflushメッセージが表示されたままになります。

`flash.now[<ラベル>]=<メッセージ>` とすることで、画面表示を伴わない再表示時にもメッセージが消えるようになります。

[source, rb]
.app/controllers/sessions_controller.rb
----
class SessionsController < ApplicationController
  def new
  end

  def create
    # <1>
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      # <2>
      # TODO: ログイン処理
      redirect_to user
    else
      # <3>
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
  end
end
----

<1> メールアドレスでユーザを検索し、パスワードで認証を試す
<2> 認証に成功した場合、ログイン処理を行い、ユーザ表示画面へリダイレクトする。（ログイン処理未実装）
<2> 認証に失敗した場合、ログイン画面を表示する。フラッシュメッセージを表示する。

ユーザモデル実装時に、メールアドレスは小文字に変換してDBに保存するようにしました。
そのため、メールアドレスでユーザを検索する場合、小文字に変換した文字列で検索する必要があります。

image:images/login.png[ログイン画面]

image:images/login_error.png[ログイン失敗]

ログイン失敗時のテストを実装します。

テストで確認するのは以下の3点です。

* ログイン失敗時はログイン画面を再表示すること
* ログイン失敗時にフラッシュメッセージを表示する
* 他の画面へ遷移した時にフラッシュメッセージが消える

まずはログインの統合テストを生成します。

[source, console]
.ログインの統合テスト生成
----
$ rails generate integration_test users_login
----

ログイン失敗のテストを実装します。

----
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest
  def setup
    @user = users(:akihiro)
  end

  test "login with invalid information" do
    # <1>
    get login_path
    assert_template 'sessions/new'

    # <3>
    post login_path, params: { session: { email: "", password: "" } }
    assert_template 'sessions/new'

    # <4>
    assert_not flash.empty?
    assert_select 'div.alert-danger'

    # <5>
    get root_path
    assert flash.empty?
    assert_select 'div.alert-danger', 0
  end
end
----

<1> ログイン画面を表示する

<2> ログイン失敗するとログイン画面が表示される。

<3> ログイン失敗するとフラッシュメッセージが表示される。

<4> ログイン失敗後、他の画面に遷移すると、フラッシュメッセージが消える。

==== セッション管理

セッション操作処理を実装します。
コントローラに直接実装しても良いのですが、他のコントローラのアクションからログイン状態を確認できるようにしたいので、ヘルパクラスとして実装します。

MVC的にはコントローラから他のコントローラへアクセスするような同一レイヤー間で直接やりとりするのは好ましくないのです。

ヘルパクラスにセッション管理機能を実装していくのですが、他のコントローラからも使用できるようにするためにApplicationControllerへインクルード（Mix-in）します。

[source, rb]
----
class ApplicationController < ActionController::Base
  protect_from_forgery with: :exception
  include SessionsHelper # <1>
end
----

<1> セッションヘルパをインクルードする

これでアプリケーション全体でセッションヘルパを使用できるようになりました。

ログイン処理を実装します。
ログイン処理ではセッションへユーザIDを保存します。
セッションへ値を保存するにはsessionメソッドを使用します。

[source, rb]
.app/helpers/sessions_helper.rb
----
module SessionsHelper
  def log_in(user)
    session[:user_id] = user.id # <1>
  end
end
----

<1> セッションへユーザIDを格納する

では、ログイン画面に組み込んでみましょう。

[source, rb]
----
class SessionsController < ApplicationController
  def new
  end

  def create
    user = User.find_by(email: params[:session][:email].downcase)
    if user && user.authenticate(params[:session][:password])
      log_in(user)  # <1>
      redirect_to user
    else
      flash.now[:danger] = 'Invalid email/password combination'
      render 'new'
    end
  end

  def destroy
  end
end
----

<1> ログイン処理を追加

これでログイン出来るようになりました。

とはいえ、このままだとなんちゃってログイン機能です。
ログイン出来てもなにも変わりません。

ということで、ログイン中かどうかを判別出来るようにして、ログイン中はログアウトボタンが表示されるようにしてみましょう。

ログイン処理で保存したユーザIDのユーザが実際に存在するかどうかでログイン中かどうかを判断します。

[source, rb]
.app/helpers/sessions_helper.rb
----
module SessionsHelper
  # <1>
  def current_user
    @current_user ||= User.find_by(id: session[:user_id])
  end

  #<2>
  def logged_in?
    !current_user.nil?
  end
end
----

<1> ログイン中のユーザを取得する
<2> ログイン中かどうかを取得する

次にビューを変更します。
ヘッダ部分のログインボタンを、ログイン中はAccountボタンを表示します。
Accountボタンはドロップダウンメニューを表示し、その中にログアウトボタンとユーザ表示画面へのリンクのProfileボタンを持たせます。

[source, html]
----
<!DOCTYPE html>
<html>
  <head>
    <title><%= yield(:title) %> | Ruby on Rails Example</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>
  <body>
    <header class="navbar navbar-fixed-top navbar-inverse">
      <div class="container">
        <%= link_to "Ruby on Rails Example", '#', id: "logo" %>
        <nav>
          <ul class="nav navbar-nav navbar-right">
            <li><%= link_to "Home",   '#' %></li>

            <% if logged_in? %>
              <!-- 1 -->
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                  Account <b class="caret"></b>
                </a>
                <ul class="dropdown-menu">
                  <li><%= link_to "Profile", current_user %></li>
                  <li><%= link_to "Log out", logout_path, method: :delete %></li>
                </ul>
              </li>
            <% else %>
              <!-- 2 -->
              <li><%= link_to "Log in", login_path %></li>
            <% end %>

          </ul>
        </nav>
      </div>
    </header>
    <div class="container">
      <% flash.each do |message_type, message| %>
        <div class="alert alert-<%= message_type %>"><%= message %></div>
      <% end %>
      <%= yield %>
    </div>
  </body>
</html>
----

<1> ログイン中はAccountボタンを表示する。AccountボタンはProfileボタンとLog outボタンを持つドロップダウンメニューを表示する。
<2> ログイン中でなければLog inボタンを表示する

[suppress='InvalidSymbol']
Profileボタンのリンク先を `current_user` としていますが、これは `user_path(current_user)` の省略です。

ドロップダウンメニューの表示はbootstrap任せです。
dropdownクラスとdropdown-menuクラスを使うことで、bootstrapはドロップダウンメニューの表示を実現します。

ログインしてみます。
ログインすると、表示が変わりましたね。
このままだとブラウザを一旦終了しないとログイン状態が解除されないので、ログアウトを実装します。

ログアウトではログイン処理でsesseionに格納したユーザIDを削除します。
sessionのデータを削除するには**delete**メソッドを使用します。

[source, rb]
.app/helpers/sessions_helper.rb
----
module SessionsHelper
  def log_out
    session.delete(:user_id)
    @current_user = nil
  end
end
----

セッションコントローラのdestoroyアクションへ実装したログアウト処理を組み込みましょう。
ログアウト後はルートへリダイレクトします。

[source, rb]
.app/controllers/sessions_controller.rb
----
class SessionsController < ApplicationController
  def destroy
    log_out
    redirect_to root_path
  end
end
----

ではログイン中にログアウトボタンを押してみましょう。

ルートに遷移し、ログインボタンが表示されるようになりましたね。

では、テストを実装しましょう。

[source, rb]
----
require 'test_helper'

class UsersLoginTest < ActionDispatch::IntegrationTest
  test 'login with valid information' do
    # <1>
    get login_path

    # <2>
    post login_path, params: { session: { email:    @user.email,
                                          password: 'password' } }
    assert_redirected_to @user
    follow_redirect!
    assert_template 'users/show'

    # <3>
    assert_select 'a[href=?]', login_path, count: 0
    assert_select 'a[href=?]', logout_path
    assert_select "a[href=?]", user_path(@user)

    # <4>
    delete logout_path
    assert_not is_logged_in?
    assert_redirected_to root_url
    follow_redirect!

    # <5>
    assert_select 'a[href=?]', login_path
    assert_select 'a[href=?]', logout_path,      count: 0
    assert_select 'a[href=?]', user_path(@user), count: 0
  end
end
----

<1> ログイン画面を表示する
<2> ログイン成功するとログインしたユーザのユーザ表示画面へリダイレクトする。
<3> ログイン成功すると、log inボタンが表示されない。log outボタンとProfileボタンが表示される。
<4> ログアウトすると、ルートへリダイレクトする。
<5> ログアウトすると、log inボタンが表示される。log outボタンとProfileボタンが表示されない。
